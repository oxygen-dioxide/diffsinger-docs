<a name="UAD1Y"></a>
# 一、常规特化
<a name="nzx5U"></a>
## 1、将目标音色A的数据集，使用B模型转换一遍，得到A内容、B音色的wav数据集
<a name="D1grh"></a>
## 2、预先提取此数据集的units，得到A内容、B音色的units
*注：使用batch.py、units设为True、加载B模型，把A数据集（wav）放到batch文件夹内，会自动导出特化所需的units至batch文件夹
<a name="rNO1m"></a>
## 3、将上步得到的units，与目标音色A的数据集放到同文件夹下，以正常流程进行训练
<a name="dxzka"></a>
## 4、程序检测到数据集中有npy格式的units会自动加载、不再临时提取
<a name="daVPK"></a>
## 5、特化训练即units（B音色、A编码内容）+f0→mel（A音色、A原内容）的映射关系，得到的模型仅允许B音色的音频输入、转换质量也会更高

<a name="oVXfE"></a>
## 推理：
特化推理时完成的是，units（B音色、数据集包含任意内容）+f0→mel（A音色、对应内容）的映射关系，与训练条件更接近（均为B→A）<br />所以特化模型可以解决音色泄露等问题，得到更高的转换质量

<a name="Y6u5N"></a>
# 二.特化进阶
<a name="C4W7I"></a>
## 循环特化
特化训练可得B→A的高质量转换模型；同理，以此模型作为预模型导出units，可得A→B的特化模型<br />重复多次后，A、B音色间的转换损耗越来越小，效果更佳

<a name="wPdqg"></a>
## 多项特化
可以分别使用B、C、D等音色炼制预模型<br />将A数据集分为多份，分别导出A内容、BCD音色的数据集，进行特化训练<br />由此得到B、C、D三种固定输入、A音色一种固定输出的特化模型（因输入条件更复杂、数据集数量需求更大）

<a name="LRIPF"></a>
## 音色抵抗
将数据集A拆为数份，使用不同音色units特化；此时可认为，模型进行了B、C、D三种音色的适应训练<br />将数据集A复制数份，使用不同音色units特化；会出现下列特殊情况：<br />1、X units、B音色 → X mel、A音色<br />2、X units、C音色 → X mel、A音色<br />3、X units、D音色 → X mel、A音色<br />同一份内容X，有多种音色的units同时指向了同一份X mel;模型更容易总结出相同点（语义信息），忽略音色泄露的信息<br />在音色种类足够时，这种特殊情况相对某几种音色的适应训练、更偏向于对陌生音色的抵抗训练，更加泛化
